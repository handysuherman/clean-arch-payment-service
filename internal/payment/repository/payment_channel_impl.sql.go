// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: payment_channel_impl.sql

package repository

import (
	"context"

	"github.com/shopspring/decimal"
)

const createPaymentChannel = `-- name: CreatePaymentChannel :one
INSERT INTO payment_channel (
    uid,
    pcname,
    pc_type,
    min_amount,
    max_amount,
    tax,
    is_tax_percentage
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING uid, pcname, pc_type, logo_src, min_amount, max_amount, tax, is_tax_percentage, is_active, is_available
`

type CreatePaymentChannelParams struct {
	Uid             string          `json:"uid"`
	Pcname          string          `json:"pcname"`
	PcType          string          `json:"pc_type"`
	MinAmount       decimal.Decimal `json:"min_amount"`
	MaxAmount       decimal.Decimal `json:"max_amount"`
	Tax             decimal.Decimal `json:"tax"`
	IsTaxPercentage bool            `json:"is_tax_percentage"`
}

func (q *Queries) CreatePaymentChannel(ctx context.Context, arg *CreatePaymentChannelParams) (*PaymentChannel, error) {
	row := q.db.QueryRow(ctx, createPaymentChannel,
		arg.Uid,
		arg.Pcname,
		arg.PcType,
		arg.MinAmount,
		arg.MaxAmount,
		arg.Tax,
		arg.IsTaxPercentage,
	)
	var i PaymentChannel
	err := row.Scan(
		&i.Uid,
		&i.Pcname,
		&i.PcType,
		&i.LogoSrc,
		&i.MinAmount,
		&i.MaxAmount,
		&i.Tax,
		&i.IsTaxPercentage,
		&i.IsActive,
		&i.IsAvailable,
	)
	return &i, err
}

const getAvailablePaymentChannel = `-- name: GetAvailablePaymentChannel :one
SELECT uid, pcname, pc_type, logo_src, min_amount, max_amount, tax, is_tax_percentage, is_active, is_available FROM payment_channel WHERE pc_type = $1 AND pcname = $2 AND $3 > min_amount AND $3 < max_amount AND is_active = true AND is_available = true LIMIT 1
`

type GetAvailablePaymentChannelParams struct {
	PcType    string          `json:"pc_type"`
	Pcname    string          `json:"pcname"`
	MinAmount decimal.Decimal `json:"min_amount"`
}

func (q *Queries) GetAvailablePaymentChannel(ctx context.Context, arg *GetAvailablePaymentChannelParams) (*PaymentChannel, error) {
	row := q.db.QueryRow(ctx, getAvailablePaymentChannel, arg.PcType, arg.Pcname, arg.MinAmount)
	var i PaymentChannel
	err := row.Scan(
		&i.Uid,
		&i.Pcname,
		&i.PcType,
		&i.LogoSrc,
		&i.MinAmount,
		&i.MaxAmount,
		&i.Tax,
		&i.IsTaxPercentage,
		&i.IsActive,
		&i.IsAvailable,
	)
	return &i, err
}

const getAvailablePaymentChannels = `-- name: GetAvailablePaymentChannels :many
SELECT uid, pcname, pc_type, logo_src, min_amount, max_amount, tax, is_tax_percentage, is_active, is_available FROM payment_channel WHERE  $1 > min_amount  AND $1 < max_amount AND is_active = true AND is_available = true
`

func (q *Queries) GetAvailablePaymentChannels(ctx context.Context, minAmount decimal.Decimal) ([]*PaymentChannel, error) {
	rows, err := q.db.Query(ctx, getAvailablePaymentChannels, minAmount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*PaymentChannel{}
	for rows.Next() {
		var i PaymentChannel
		if err := rows.Scan(
			&i.Uid,
			&i.Pcname,
			&i.PcType,
			&i.LogoSrc,
			&i.MinAmount,
			&i.MaxAmount,
			&i.Tax,
			&i.IsTaxPercentage,
			&i.IsActive,
			&i.IsAvailable,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentChannelByID = `-- name: GetPaymentChannelByID :one
SELECT uid, pcname, pc_type, logo_src, min_amount, max_amount, tax, is_tax_percentage, is_active, is_available FROM payment_channel WHERE uid = $1 LIMIT 1
`

func (q *Queries) GetPaymentChannelByID(ctx context.Context, uid string) (*PaymentChannel, error) {
	row := q.db.QueryRow(ctx, getPaymentChannelByID, uid)
	var i PaymentChannel
	err := row.Scan(
		&i.Uid,
		&i.Pcname,
		&i.PcType,
		&i.LogoSrc,
		&i.MinAmount,
		&i.MaxAmount,
		&i.Tax,
		&i.IsTaxPercentage,
		&i.IsActive,
		&i.IsAvailable,
	)
	return &i, err
}

const getPaymentChannelByName = `-- name: GetPaymentChannelByName :one
SELECT uid, pcname, pc_type, logo_src, min_amount, max_amount, tax, is_tax_percentage, is_active, is_available FROM payment_channel WHERE pcname = $1 LIMIT 1
`

func (q *Queries) GetPaymentChannelByName(ctx context.Context, pcname string) (*PaymentChannel, error) {
	row := q.db.QueryRow(ctx, getPaymentChannelByName, pcname)
	var i PaymentChannel
	err := row.Scan(
		&i.Uid,
		&i.Pcname,
		&i.PcType,
		&i.LogoSrc,
		&i.MinAmount,
		&i.MaxAmount,
		&i.Tax,
		&i.IsTaxPercentage,
		&i.IsActive,
		&i.IsAvailable,
	)
	return &i, err
}
